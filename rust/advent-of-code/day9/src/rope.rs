use std::collections::HashSet;

use crate::pos::Direction;
use crate::pos::Pos;

pub struct Rope {
    knots: Vec<Pos>,
    tail_positions: HashSet<Pos>,
}

impl Rope {
    pub fn new(size: usize) -> Self {
        assert!(size > 0);
        let knots = vec![Pos::new(0, 0); size];
        let mut return_val = Self {
            knots,
            tail_positions: HashSet::new(),
        };
        return_val.store_tail_pos();
        return_val
    }

    fn get_head(&self) -> &Pos {
        &self.knots.first().unwrap()
    }

    fn get_tail(&self) -> &Pos {
        &self.knots.last().unwrap()
    }

    pub fn get_tail_positions(&self) -> &HashSet<Pos> {
        &self.tail_positions
    }

    pub fn make_move(&mut self, direction: Direction) {
        // move head
        let head = self.knots.first_mut().unwrap();
        *head = *head + &direction;
        let num_knots = self.knots.iter().count() - 1;
        for i in 0..num_knots {
            self.update_tailing_knot_of(i);
        }
        
        self.store_tail_pos();
    }

    /// . c c c .
    /// c s s s c
    /// c s H s c
    /// c s s s c
    /// . c c c .
    /// 
    /// H - head
    /// s - stay (leave tail in the same position)
    /// c - change (change tail position)
    /// . - error
    fn update_tailing_knot_of(&mut self, index: usize) {
        let head = self.knots.get(index).unwrap().clone();
        let tail = self.knots.get_mut(index + 1).unwrap();
        if head == *tail {
            return;
        }
        let x_diff = head.x - tail.x;
        let y_diff = head.y - tail.y;
        if x_diff.abs() <= 1 && y_diff.abs() <= 1 {
            return;
        }
        let new_tail_pos = Pos::new(
            tail.x + divide_and_round(x_diff, 2),
            tail.y + divide_and_round(y_diff, 2),
        );
       *tail = new_tail_pos;
    }

    fn store_tail_pos(&mut self) {
        self.tail_positions.insert(self.get_tail().clone());
    }
}

/// Function generated by ChatGPL ðŸŽ‰
fn divide_and_round(a: i32, b: i32) -> i32 {
    // Divide the two numbers
    let result = a as f64 / b as f64;

    // If the result is positive, round up to the nearest integer
    // If the result is negative, round down to the nearest integer
    if result >= 0.0 {
        result.ceil() as i32
    } else {
        result.floor() as i32
    }
}

#[cfg(test)]
mod tests {
    use std::collections::HashSet;

    use rstest::*;
    use super::{Rope, divide_and_round};
    use crate::pos::{Direction, Pos};
    use Direction::*;

    #[test]
    fn test_move_rope() {
        let moves_sequence = [
            (Up, Pos::new(0, 1)),
            (Up, Pos::new(0, 2)),
            (Left, Pos::new(-1, 2)),
            (Down, Pos::new(-1, 1)),
            (Right, Pos::new(0, 1)),
            (Right, Pos::new(1, 1)),
            (Right, Pos::new(2, 1)),
            (Right, Pos::new(3, 1)),
            (Right, Pos::new(4, 1)),
        ];
        let mut rope = Rope::new(2);
        for (direction, expected_pos) in moves_sequence {
            rope.make_move(direction);
            assert_eq!(rope.get_head(), &expected_pos);
        }
    }

    #[rstest]
    #[case(Pos::new(0, 0), Pos::new(0, 0), Pos::new(0, 0))]
    #[case(Pos::new(0, 1), Pos::new(0, 0), Pos::new(0, 0))]
    #[case(Pos::new(0, 2), Pos::new(0, 0), Pos::new(0, 1))]
    #[case(Pos::new(0, 1), Pos::new(0, 0), Pos::new(0, 0))]
    #[case(Pos::new(102, 101), Pos::new(100, 100), Pos::new(101, 101))]
    #[case(Pos::new(2, 3), Pos::new(1, 1), Pos::new(2, 2))]
    #[case(Pos::new(3, 1), Pos::new(1, 1), Pos::new(2, 1))]
    #[case(Pos::new(1, 1), Pos::new(1, 3), Pos::new(1, 2))]
    #[case(Pos::new(1, 1), Pos::new(1, 2), Pos::new(1, 2))]
    #[case(Pos::new(1, 1), Pos::new(2, 2), Pos::new(2, 2))]
    fn test_update_tail(#[case] head_pos: Pos, #[case] tail_pos: Pos, #[case] expected_tail_pos: Pos) {
        let mut rope = Rope::new(2);
        rope.knots[0] = head_pos;
        rope.knots[1] = tail_pos;

        rope.update_tailing_knot_of(0);
        assert_eq!(rope.get_tail(), &expected_tail_pos);
    }

    #[rstest]
    #[case(1, 2, 1)]
    #[case(0, 2, 0)]
    #[case(-1, 2, -1)]
    #[case(-2, 2, -1)]
    fn test_divide_and_round(#[case] a: i32, #[case] b: i32, #[case] result: i32) {
        let r = divide_and_round(a, b);
        assert_eq!(r, result);
    }

    #[test]
    fn test_on_example() {
        let mut rope = Rope::new(2);
        let moves = [
            Right, Right, Right, Right,
            Up, Up, Up, Up,
            Left, Left, Left,
            Down,
            Right, Right, Right, Right,
            Down,
            Left, Left, Left, Left, Left,
            Right, Right,
        ];
        for mov in moves {
            rope.make_move(mov);
        }
        assert_eq!(rope.get_tail_positions().len(), 13);
        let set: HashSet<Pos> = HashSet::from_iter([
            Pos::new(0, 0),
            Pos::new(1, 0),
            Pos::new(2, 0),
            Pos::new(3, 0),
            Pos::new(4, 1),
            Pos::new(1, 2),
            Pos::new(2, 2),
            Pos::new(3, 2),
            Pos::new(4, 2),
            Pos::new(3, 3),
            Pos::new(4, 3),
            Pos::new(2, 4),
            Pos::new(3, 4),
        ]);
        dbg!(rope.get_tail_positions());
        assert_eq!(&set, rope.get_tail_positions());
    }

    #[test]
    fn test_part2_example() {
        let moves = [
            vec![Right; 5],
            vec![Up; 8],
            vec![Left; 8],
            vec![Down; 3],
            vec![Right; 17],
            vec![Down; 10],
            vec![Left; 25],
            vec![Up; 20],
        ].concat();
        let mut rope = Rope::new(10);
        for m in moves {
            rope.make_move(m);
        }
        assert_eq!(rope.get_tail_positions().len(), 36);
    }
}
